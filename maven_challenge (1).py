# -*- coding: utf-8 -*-
"""Maven_challenge.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jYoxzvtfwGR83xG_FA3kX9RlZVYE2vLq
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime

df=pd.read_csv("marketing_data.csv")

df.head()

df.info()

df.describe()

df.isnull().sum()

# Calculer la m√©diane
median_income = df['Income'].median()

# Remplacer les valeurs manquantes
df['Income'].fillna(median_income, inplace=True)

# V√©rification
print(df['Income'].isnull().sum())

print(df.columns.tolist())

df.columns = df.columns.str.strip()

median_income = df['Income'].median()
median_income

df['Income'].fillna(median_income, inplace=True)
print(df['Income'].isnull().sum())

df['Income'] = df['Income'].replace({',': ''}, regex=True)
df['Income'] = pd.to_numeric(df['Income'], errors='coerce')

mnt_columns = ['MntWines', 'MntFruits', 'MntMeatProducts',
               'MntFishProducts', 'MntSweetProducts', 'MntGoldProds']
df['Total_Spent'] = df[mnt_columns].sum(axis=1)

df['Total_Children'] = df['Kidhome'] + df['Teenhome']

campaign_cols = ['AcceptedCmp1', 'AcceptedCmp2', 'AcceptedCmp3',
                'AcceptedCmp4', 'AcceptedCmp5', 'Response']
df['Total_Accepted_Campaigns'] =df[campaign_cols].sum(axis=1)

purchase_cols = ['NumWebPurchases', 'NumCatalogPurchases', 'NumStorePurchases']
df['Total_Purchases'] = df[purchase_cols].sum(axis=1)

current_year = datetime.now().year
df['Age'] = current_year - df['Year_Birth']

print(df[['Age', 'Total_Spent', 'Total_Children',
                'Total_Accepted_Campaigns', 'Total_Purchases']].head())

df.head()

# Configuration basique
plt.style.use('default')
sns.set_palette("husl")

# 1. Distribution des variables principales
fig, axes = plt.subplots(2, 3, figsize=(15, 10))

# √Çge
axes[0,0].hist(df['Age'], bins=20, alpha=0.7, edgecolor='black')
axes[0,0].set_title('Distribution des √Çges')
axes[0,0].set_xlabel('√Çge')

# Revenu
axes[0,1].hist(df['Income'], bins=25, alpha=0.7, edgecolor='black')
axes[0,1].set_title('Distribution des Revenus')
axes[0,1].set_xlabel('Revenu')

# D√©penses totales
axes[0,2].hist(df['Total_Spent'], bins=25, alpha=0.7, edgecolor='black')
axes[0,2].set_title('D√©penses Totales')
axes[0,2].set_xlabel('D√©penses')

# R√©ponse aux campagnes
response_counts = df['Response'].value_counts()
axes[1,0].bar(['Non', 'Oui'], response_counts.values, alpha=0.7)
axes[1,0].set_title('R√©ponse aux Campagnes')
axes[1,0].set_ylabel('Nombre')

# √âducation
df['Education'].value_counts().plot(kind='bar', ax=axes[1,1], alpha=0.7)
axes[1,1].set_title('Niveau d\'√âducation')
axes[1,1].tick_params(axis='x', rotation=45)

# Enfants
df['Total_Children'].value_counts().sort_index().plot(kind='bar', ax=axes[1,2], alpha=0.7)
axes[1,2].set_title('Nombre d\'Enfants')
axes[1,2].set_xlabel('Enfants')

plt.tight_layout()
plt.show()

# 2. Boxplots pour comparer r√©pondants vs non-r√©pondants
fig, axes = plt.subplots(2, 2, figsize=(12, 8))

# Revenu
sns.boxplot(x='Response', y='Income', data=df, ax=axes[0,0])
axes[0,0].set_title('Revenu par R√©ponse')
axes[0,0].set_xticklabels(['Non', 'Oui'])

# D√©penses
sns.boxplot(x='Response', y='Total_Spent', data=df, ax=axes[0,1])
axes[0,1].set_title('D√©penses par R√©ponse')
axes[0,1].set_xticklabels(['Non', 'Oui'])

# √Çge
sns.boxplot(x='Response', y='Age', data=df, ax=axes[1,0])
axes[1,0].set_title('√Çge par R√©ponse')
axes[1,0].set_xticklabels(['Non', 'Oui'])

# Achats
sns.boxplot(x='Response', y='Total_Purchases', data=df, ax=axes[1,1])
axes[1,1].set_title('Achats par R√©ponse')
axes[1,1].set_xticklabels(['Non', 'Oui'])

plt.tight_layout()
plt.show()

mnt_columns = [col for col in df.columns if 'Mnt' in col]
df['Total_Spent'] = df[mnt_columns].sum(axis=1)

# Total achats
purchase_cols = [col for col in df.columns if 'Purchases' in col and 'Num' in col]
df['Total_Purchases'] = df[purchase_cols].sum(axis=1)

# Enfants totaux
df['Total_Children'] = df['Kidhome'] + df['Teenhome']

# √Çge
current_year = pd.Timestamp.now().year
df['Age'] = current_year - df['Year_Birth']

# Nouvelle matrice de corr√©lation avec bons noms
corr_columns = ['Income', 'Total_Spent', 'Total_Purchases', 'Recency', 'Age', 'Total_Children', 'Response']
corr_matrix = df[corr_columns].corr()

print("Matrice de corr√©lation CORRIG√âE:")
print(corr_matrix.round(2))

# =============================================================================
# CORRELATION ANALYSIS - KEY BUSINESS INSIGHTS
# =============================================================================

# üéØ CAMPAIGN RESPONSE DRIVERS:
# ‚Ä¢ Total_Spent (+0.27): High-spending customers are 27% more likely to respond to campaigns
# ‚Ä¢ Income (+0.13): Higher income customers show better response rates
# ‚Ä¢ Total_Purchases (+0.16): Active shoppers are more receptive to marketing
# ‚Ä¢ Recency (-0.20): Recent customers are 20% more likely to respond - crucial for timing!
# ‚Ä¢ Total_Children (-0.17): Customers with fewer children respond better to campaigns

# üí∞ SPENDING BEHAVIOR PATTERNS:
# ‚Ä¢ Income vs Total_Spent (+0.66): Strong positive relationship - higher income = higher spending
# ‚Ä¢ Total_Spent vs Total_Children (-0.50): Customers with children spend 50% less
# ‚Ä¢ Total_Spent vs Total_Purchases (+0.75): High correlation - big spenders shop frequently

# üöÄ STRATEGIC IMPLICATIONS:
# ‚Ä¢ TARGET: High-income, child-free customers who recently purchased
# ‚Ä¢ FOCUS: Recent customers for immediate campaign success
# ‚Ä¢ SEGMENT: Big spenders and frequent shoppers as priority targets
# ‚Ä¢ TIMING: Capitalize on recency effect for higher conversion rates

# üí° RECOMMENDATIONS:
# 1. Create 'High-Value Recent Buyers' segment for premium campaigns
# 2. Develop child-free customer targeting strategies
# 3. Implement recency-based campaign triggers
# 4. Focus on high-income geographic areas
# =============================================================================

# STEP 1: UNDERSTANDING CLUSTERING
# =============================================================================
# Goal: Group similar customers into categories
# Example: "Young big spenders", "Budget families", "Loyal seniors"
# Method: K-means - algorithm that finds groups automatically

# List of features we'll use to create groups
features = ['Income', 'Total_Spent', 'Total_Purchases', 'Recency', 'Age', 'Total_Children']

print("üìã FEATURES WE'LL USE:")
for i, feature in enumerate(features, 1):
    print(f"{i}. {feature}")

# Data preview
print(f"\nüìä Data preview (first rows):")
print(df[features].head())

#STEP 3: DATA NORMALIZATION
# =============================================================================
# Why? Because income (ex: 50,000) and age (ex: 45) have different scales
# We need to put everything on the same scale for the algorithm to work properly
# =============================================================================

from sklearn.preprocessing import StandardScaler

# Create the "normalizer"
scaler = StandardScaler()

# Apply normalization
df_scaled = scaler.fit_transform(df[features])

print("‚úÖ Data normalized!")
print(f"Before normalization - Average income: {df['Income'].mean():.0f}")
print(f"After normalization - Average: {df_scaled[:,0].mean():.2f} (always ~0)")

# =============================================================================
# STEP 4: FINDING THE RIGHT NUMBER OF GROUPS
# =============================================================================
# We test different numbers of groups (2, 3, 4, 5, 6)
# We see which number works best
# =============================================================================

from sklearn.cluster import KMeans

# Test different numbers of clusters
inertias = []
for k in range(2, 7):
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(df_scaled)
    inertias.append(kmeans.inertia_)

# Visualization
plt.figure(figsize=(10, 6))
plt.plot(range(2, 7), inertias, 'bo-', markersize=8)
plt.xlabel('Number of Groups')
plt.ylabel('Inertia (error)')
plt.title('Elbow Method - Choosing Number of Groups')
plt.grid(True, alpha=0.3)
plt.show()

# Elbow Analysis Result: 4 Optimal Customer Segments
# The "elbow" clearly bends at k=4 - this is our sweet spot
# Going beyond 4 segments provides diminishing returns
# Proceeding with 4 clusters for customer segmentation

# =============================================================================
# STEP 5: CREATE THE 4 CUSTOMER SEGMENTS
# =============================================================================
# We found that 4 groups is optimal from the elbow method
# Now let's actually create these customer segments
# =============================================================================

print("üéØ CREATING 4 CUSTOMER SEGMENTS...")

# Create K-means model with 4 clusters
kmeans = KMeans(n_clusters=4, random_state=42, n_init=10)

# Apply clustering to our scaled data
cluster_labels = kmeans.fit_predict(df_scaled)

# Add cluster labels to our original dataframe
df['Cluster'] = cluster_labels

print("‚úÖ CUSTOMER SEGMENTS CREATED SUCCESSFULLY!")
print("   Each customer now belongs to one of 4 segments (0, 1, 2, 3)")

# Check how many customers in each segment
cluster_counts = df['Cluster'].value_counts().sort_index()
print(f"\nüìä CUSTOMER DISTRIBUTION ACROSS SEGMENTS:")
for cluster_num, count in cluster_counts.items():
    print(f"   Segment {cluster_num}: {count} customers ({count/len(df)*100:.1f}%)")

# =============================================================================
# STEP 6: UNDERSTAND WHAT EACH SEGMENT LOOKS LIKE
# =============================================================================
# Now let's analyze the characteristics of each customer segment
# This is where we understand WHO these customers are
# =============================================================================

print("üîç ANALYZING SEGMENT CHARACTERISTICS...")

# Calculate average values for each segment
segment_profiles = df.groupby('Cluster')[features].mean()

print("\nüìà AVERAGE VALUES FOR EACH SEGMENT:")
print(segment_profiles.round(2))

# Calculate how each segment differs from overall average
overall_means = df[features].mean()

print("\nüìä HOW EACH SEGMENT DIFFERS FROM AVERAGE CUSTOMER (% DIFFERENCE):")

for segment in range(4):
    segment_data = segment_profiles.loc[segment]
    differences = ((segment_data - overall_means) / overall_means * 100).round(1)

    print(f"\n--- SEGMENT {segment} ({cluster_counts[segment]} customers) ---")

    # Find what makes this segment unique
    highest_above = differences.nlargest(2)
    lowest_below = differences.nsmallest(2)

    print("ABOVE average in:")
    for feature, diff in highest_above.items():
        print(f"   üü¢ {feature}: +{diff}%")

    print("BELOW average in:")
    for feature, diff in lowest_below.items():
        print(f"   üî¥ {feature}: {diff}%")

print("üìà LET'S CALCULATE THE OVERALL AVERAGES FIRST:")

# Calculate average of all customers
overall_avg_income = df['Income'].mean()
overall_avg_spent = df['Total_Spent'].mean()
overall_avg_purchases = df['Total_Purchases'].mean()
overall_avg_children = df['Total_Children'].mean()
overall_avg_age = df['Age'].mean()

print(f"‚Ä¢ Average Income: ${overall_avg_income:,.0f}")
print(f"‚Ä¢ Average Total Spent: ${overall_avg_spent:,.0f}")
print(f"‚Ä¢ Average Purchases: {overall_avg_purchases:.1f}")
print(f"‚Ä¢ Average Children: {overall_avg_children:.1f}")
print(f"‚Ä¢ Average Age: {overall_avg_age:.1f} years")

# =============================================================================
# STEP 4: ANALYZE SEGMENT 0
# =============================================================================

print("\n" + "="*50)
print("üîç ANALYZING SEGMENT 0:")
print("="*50)

segment_0_data = segment_profiles.loc[0]

print("üìä THEIR AVERAGES:")
print(f"‚Ä¢ Income: ${segment_0_data['Income']:,.0f}")
print(f"‚Ä¢ Total Spent: ${segment_0_data['Total_Spent']:,.0f}")
print(f"‚Ä¢ Purchases: {segment_0_data['Total_Purchases']:.1f}")
print(f"‚Ä¢ Children: {segment_0_data['Total_Children']:.1f}")
print(f"‚Ä¢ Age: {segment_0_data['Age']:.1f} years")

print(f"\nüìà COMPARED TO AVERAGE CUSTOMER:")
income_diff_0 = ((segment_0_data['Income'] - overall_avg_income) / overall_avg_income * 100)
spent_diff_0 = ((segment_0_data['Total_Spent'] - overall_avg_spent) / overall_avg_spent * 100)
purchases_diff_0 = ((segment_0_data['Total_Purchases'] - overall_avg_purchases) / overall_avg_purchases * 100)

print(f"‚Ä¢ Income: {income_diff_0:+.1f}% different")
print(f"‚Ä¢ Spending: {spent_diff_0:+.1f}% different")
print(f"‚Ä¢ Purchases: {purchases_diff_0:+.1f}% different")

print(f"\nüí° WHAT THIS MEANS:")
print("‚Ä¢ They spend MORE than average (+29.6%)")
print("‚Ä¢ They shop MORE frequently than average (+45.3%)")
print("‚Ä¢ Their income is about average")
print("‚Ä¢ They have about 1 child on average")
print("‚Ä¢ They are older than average (60.8 years)")

print(f"\nüè∑Ô∏è GOOD NAME FOR THEM: 'ACTIVE SENIOR SHOPPERS'")
print("   Because they're older but shop frequently and spend well")

# =============================================================================
# STEP 5: ANALYZE SEGMENT 1
# =============================================================================

print("\n" + "="*50)
print("üîç ANALYZING SEGMENT 1:")
print("="*50)

segment_1_data = segment_profiles.loc[1]

print("üìä THEIR AVERAGES:")
print(f"‚Ä¢ Income: ${segment_1_data['Income']:,.0f}")
print(f"‚Ä¢ Total Spent: ${segment_1_data['Total_Spent']:,.0f}")
print(f"‚Ä¢ Purchases: {segment_1_data['Total_Purchases']:.1f}")
print(f"‚Ä¢ Children: {segment_1_data['Total_Children']:.1f}")
print(f"‚Ä¢ Age: {segment_1_data['Age']:.1f} years")

print(f"\nüìà COMPARED TO AVERAGE CUSTOMER:")
income_diff_1 = ((segment_1_data['Income'] - overall_avg_income) / overall_avg_income * 100)
spent_diff_1 = ((segment_1_data['Total_Spent'] - overall_avg_spent) / overall_avg_spent * 100)
purchases_diff_1 = ((segment_1_data['Total_Purchases'] - overall_avg_purchases) / overall_avg_purchases * 100)
age_diff_1 = ((segment_1_data['Age'] - overall_avg_age) / overall_avg_age * 100)

print(f"‚Ä¢ Income: {income_diff_1:+.1f}% different")
print(f"‚Ä¢ Spending: {spent_diff_1:+.1f}% different")
print(f"‚Ä¢ Purchases: {purchases_diff_1:+.1f}% different")
print(f"‚Ä¢ Age: {age_diff_1:+.1f}% different")

print(f"\nüí° WHAT THIS MEANS:")
print("‚Ä¢ They spend MUCH LESS than average (-81.5%)")
print("‚Ä¢ They shop MUCH LESS frequently than average (-46.4%)")
print("‚Ä¢ Their income is BELOW average")
print("‚Ä¢ They have FEWER children than average (0.8)")
print("‚Ä¢ They are YOUNGER than average (48.4 years)")

print(f"\nüè∑Ô∏è GOOD NAME FOR THEM: 'YOUNG LOW SPENDERS'")
print("   Because they're young but don't spend much or shop often")

# =============================================================================
# STEP 6: ANALYZE SEGMENT 2
# =============================================================================

print("\n" + "="*50)
print("üîç ANALYZING SEGMENT 2:")
print("="*50)

segment_2_data = segment_profiles.loc[2]

print("üìä THEIR AVERAGES:")
print(f"‚Ä¢ Income: ${segment_2_data['Income']:,.0f}")
print(f"‚Ä¢ Total Spent: ${segment_2_data['Total_Spent']:,.0f}")
print(f"‚Ä¢ Purchases: {segment_2_data['Total_Purchases']:.1f}")
print(f"‚Ä¢ Children: {segment_2_data['Total_Children']:.1f}")
print(f"‚Ä¢ Age: {segment_2_data['Age']:.1f} years")

print(f"\nüìà COMPARED TO AVERAGE CUSTOMER:")
income_diff_2 = ((segment_2_data['Income'] - overall_avg_income) / overall_avg_income * 100)
spent_diff_2 = ((segment_2_data['Total_Spent'] - overall_avg_spent) / overall_avg_spent * 100)
purchases_diff_2 = ((segment_2_data['Total_Purchases'] - overall_avg_purchases) / overall_avg_purchases * 100)
children_diff_2 = ((segment_2_data['Total_Children'] - overall_avg_children) / overall_avg_children * 100)

print(f"‚Ä¢ Income: {income_diff_2:+.1f}% different")
print(f"‚Ä¢ Spending: {spent_diff_2:+.1f}% different")
print(f"‚Ä¢ Purchases: {purchases_diff_2:+.1f}% different")
print(f"‚Ä¢ Children: {children_diff_2:+.1f}% different")

print(f"\nüí° WHAT THIS MEANS:")
print("‚Ä¢ They spend MUCH LESS than average (-79.5%)")
print("‚Ä¢ They shop LESS frequently than average (-37.3%)")
print("‚Ä¢ Their income is BELOW average")
print("‚Ä¢ They have TWICE as many children as average (+106.8%)")
print("‚Ä¢ They are OLDER than average (61.6 years)")

print(f"\nüè∑Ô∏è GOOD NAME FOR THEM: 'LARGE BUDGET FAMILIES'")
print("   Because they have large families but limited budgets")

# =============================================================================
# STEP 1: CAMPAIGN PERFORMANCE ANALYSIS BY SEGMENT
# =============================================================================

print("üìä ANALYZING CAMPAIGN PERFORMANCE ACROSS YOUR 4 SEGMENTS...")

# Calculate response rates for each campaign by segment
campaign_cols = ['AcceptedCmp1', 'AcceptedCmp2', 'AcceptedCmp3',
                 'AcceptedCmp4', 'AcceptedCmp5', 'Response']

campaign_performance = df.groupby('Cluster')[campaign_cols].mean()

print("Campaign Response Rates by Segment:")
print((campaign_performance * 100).round(1))

# Calculate which segment performs best overall
df['Total_Campaign_Response'] = df[campaign_cols].sum(axis=1)
response_by_segment = df.groupby('Cluster')['Total_Campaign_Response'].mean()

print(f"\nüéØ BEST PERFORMING SEGMENT FOR CAMPAIGNS:")
best_segment = response_by_segment.idxmax()
print(f"   Segment {best_segment}: {response_by_segment[best_segment]:.2f} avg campaign responses")

# =============================================================================
# 1. SEGMENT PROFILING - COMPREHENSIVE ANALYSIS
# =============================================================================

print("üîç COMPREHENSIVE SEGMENT PROFILING")

# Calculate comprehensive segment statistics
segment_profile = df.groupby('Cluster').agg({
    'Income': ['mean', 'median', 'std'],
    'Total_Spent': ['mean', 'median', 'std'],
    'Total_Purchases': ['mean', 'median', 'std'],
    'Recency': ['mean', 'median', 'std'],
    'Age': ['mean', 'median', 'std'],
    'Total_Children': ['mean', 'median', 'std'],
    'Response': 'mean'
}).round(2)

print("üìä DETAILED SEGMENT STATISTICS:")
print(segment_profile)

# =============================================================================
# 2. SEGMENT COMPARISON - BUSINESS INTERPRETATION
# =============================================================================

print("\nüéØ BUSINESS INTERPRETATION OF SEGMENTS:")

# Calculate percentage differences from overall average
overall_means = df[['Income', 'Total_Spent', 'Total_Purchases', 'Recency', 'Age', 'Total_Children']].mean()

for segment in range(4):
    segment_data = df[df['Cluster'] == segment]

    print(f"\n{'='*50}")
    print(f"SEGMENT {segment} - {len(segment_data)} customers ({len(segment_data)/len(df)*100:.1f}%)")
    print(f"{'='*50}")

    # Key metrics comparison
    income_ratio = (segment_data['Income'].mean() / overall_means['Income'] - 1) * 100
    spend_ratio = (segment_data['Total_Spent'].mean() / overall_means['Total_Spent'] - 1) * 100
    response_rate = segment_data['Response'].mean() * 100

    print(f"üí∞ INCOME: ${segment_data['Income'].mean():,.0f} ({income_ratio:+.1f}% vs average)")
    print(f"üõçÔ∏è  SPENDING: ${segment_data['Total_Spent'].mean():,.0f} ({spend_ratio:+.1f}% vs average)")
    print(f"üìû RESPONSE RATE: {response_rate:.1f}%")
    print(f"üë∂ CHILDREN: {segment_data['Total_Children'].mean():.1f}")
    print(f"üìÖ RECENCY: {segment_data['Recency'].mean():.0f} days since last purchase")

# =============================================================================
# 3. PURCHASE CHANNEL ANALYSIS BY SEGMENT
# =============================================================================

print("\nüõí PURCHASE CHANNEL PREFERENCES BY SEGMENT:")

# Analyze where each segment prefers to shop
channel_columns = ['NumWebPurchases', 'NumCatalogPurchases', 'NumStorePurchases', 'NumDealsPurchases']

channel_preferences = df.groupby('Cluster')[channel_columns].mean()

print("Average purchases per channel by segment:")
print(channel_preferences.round(2))

# Calculate channel preferences as percentages
channel_percentages = channel_preferences.div(channel_preferences.sum(axis=1), axis=0) * 100

print("\nüìä CHANNEL PREFERENCES (% of total purchases):")
print(channel_percentages.round(1))

# =============================================================================
# 4. PRODUCT CATEGORY ANALYSIS BY SEGMENT
# =============================================================================

print("\nüç∑ PRODUCT CATEGORY PREFERENCES BY SEGMENT:")

# Analyze what products each segment buys
product_columns = ['MntWines', 'MntFruits', 'MntMeatProducts',
                   'MntFishProducts', 'MntSweetProducts', 'MntGoldProds']

product_preferences = df.groupby('Cluster')[product_columns].mean()

print("Average spending per product category by segment:")
print(product_preferences.round(2))

# Find dominant product category for each segment
dominant_products = product_preferences.idxmax(axis=1)
print(f"\nüéØ DOMINANT PRODUCT CATEGORY FOR EACH SEGMENT:")
for segment, product in dominant_products.items():
    spending = product_preferences.loc[segment, product]
    print(f"Segment {segment}: {product} (${spending:.0f})")

# 5. CAMPAIGN PERFORMANCE DEEP DIVE
# =============================================================================

print("\nüìä CAMPAIGN PERFORMANCE DEEP DIVE BY SEGMENT:")

# Analyze each campaign separately
campaign_columns = ['AcceptedCmp1', 'AcceptedCmp2', 'AcceptedCmp3', 'AcceptedCmp4', 'AcceptedCmp5', 'Response']

campaign_performance = df.groupby('Cluster')[campaign_columns].mean() * 100

print("Campaign response rates by segment (%):")
print(campaign_performance.round(1))

# Find best campaign for each segment
best_campaigns = campaign_performance.idxmax(axis=1)
print(f"\nüéØ BEST PERFORMING CAMPAIGN FOR EACH SEGMENT:")
for segment, campaign in best_campaigns.items():
    rate = campaign_performance.loc[segment, campaign]
    print(f"Segment {segment}: {campaign} ({rate:.1f}% response)")

# 6. CUSTOMER LIFETIME VALUE ESTIMATION BY SEGMENT
# =============================================================================

print("\nüí∞ CUSTOMER LIFETIME VALUE ANALYSIS:")

# Simple CLV calculation based on spending patterns
# CLV = Average Order Value √ó Purchase Frequency √ó Customer Lifespan

# Calculate metrics for CLV
segment_clv = df.groupby('Cluster').agg({
    'Total_Spent': 'mean',
    'Total_Purchases': 'mean',
    'Recency': 'mean'
}).round(2)

segment_clv['Avg_Order_Value'] = segment_clv['Total_Spent'] / segment_clv['Total_Purchases']
segment_clv['Purchase_Frequency'] = segment_clv['Total_Purchases'] / 2  # Assuming 2-year data period

# Estimate customer lifespan based on recency (customers with lower recency likely to stay longer)
segment_clv['Estimated_Lifespan'] = (365 / (segment_clv['Recency'] + 1)).clip(upper=5)  # Cap at 5 years

# Calculate CLV
segment_clv['Estimated_CLV'] = (segment_clv['Avg_Order_Value'] *
                               segment_clv['Purchase_Frequency'] *
                               segment_clv['Estimated_Lifespan'])

print("üìä CUSTOMER LIFETIME VALUE ESTIMATES:")
print(segment_clv[['Avg_Order_Value', 'Purchase_Frequency', 'Estimated_Lifespan', 'Estimated_CLV']].round(2))

print(f"\nüéØ SEGMENT BUSINESS VALUE RANKING:")
clv_ranking = segment_clv['Estimated_CLV'].sort_values(ascending=False)
for rank, (segment, clv) in enumerate(clv_ranking.items(), 1):
    print(f"{rank}. Segment {segment}: ${clv:.0f} estimated CLV")

# =============================================================================
# 7. SEGMENT GROWTH POTENTIAL ANALYSIS
# =============================================================================

print("\nüìà SEGMENT GROWTH POTENTIAL ANALYSIS:")

# Analyze which segments have the most growth potential
growth_potential = df.groupby('Cluster').agg({
    'Income': 'mean',
    'Total_Spent': 'mean',
    'Total_Purchases': 'mean',
    'NumWebVisitsMonth': 'mean',  # Engagement indicator
    'Response': 'mean'  # Campaign responsiveness
}).round(2)

# Calculate growth potential score (custom metric)
growth_potential['Growth_Score'] = (
    (growth_potential['Income'] / growth_potential['Income'].max()) * 0.3 +
    (growth_potential['Response'] / growth_potential['Response'].max()) * 0.4 +
    (growth_potential['NumWebVisitsMonth'] / growth_potential['NumWebVisitsMonth'].max()) * 0.3
) * 100

print("üìä GROWTH POTENTIAL ASSESSMENT:")
print(growth_potential[['Income', 'Response', 'NumWebVisitsMonth', 'Growth_Score']].round(1))

print(f"\nüéØ GROWTH PRIORITY RANKING:")
growth_ranking = growth_potential['Growth_Score'].sort_values(ascending=False)
for rank, (segment, score) in enumerate(growth_ranking.items(), 1):
    print(f"{rank}. Segment {segment}: {score:.1f} growth score")

# =============================================================================
# PLOT 1: SEGMENT SIZE DISTRIBUTION
# =============================================================================

print("üìä PLOT 1: Customer Distribution Across Segments")

plt.figure(figsize=(10, 6))
segment_sizes = df['Cluster'].value_counts().sort_index()
colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4']

plt.pie(segment_sizes.values,
        labels=[f'Segment {i}' for i in segment_sizes.index],
        autopct='%1.1f%%',
        colors=colors,
        startangle=90,
        shadow=True)

plt.title('Customer Distribution Across Segments\n(Total Customers: {})'.format(len(df)),
          fontweight='bold', fontsize=14)
plt.show()

print("üí° INSIGHT: This shows how your customer base is divided")
print("   Helps prioritize which segments deserve most attention")

print("üìä PLOT 2: Revenue Contribution by Segment")

plt.figure(figsize=(10, 6))
segment_revenue = df.groupby('Cluster')['Total_Spent'].sum()

bars = plt.bar(segment_revenue.index, segment_revenue.values, color=colors, alpha=0.8)
plt.title('Total Revenue Contribution by Segment', fontweight='bold', fontsize=14)
plt.xlabel('Segment')
plt.ylabel('Total Revenue ($)')
plt.grid(axis='y', alpha=0.3)

# Add value labels on bars
for bar, value in zip(bars, segment_revenue.values):
    plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1000,
             f'${value:,.0f}', ha='center', va='bottom')

plt.show()

print("üí° INSIGHT: Shows which segments generate the most money")
print("   Compare with segment sizes to find high-value segments")

# =============================================================================
# PLOT 3: RESPONSE RATES BY SEGMENT
# =============================================================================

print("üìä PLOT 3: Campaign Response Rates by Segment")

plt.figure(figsize=(10, 6))
response_rates = df.groupby('Cluster')['Response'].mean() * 100

bars = plt.bar(response_rates.index, response_rates.values, color=colors, alpha=0.8)
plt.title('Campaign Response Rate by Segment', fontweight='bold', fontsize=14)
plt.xlabel('Segment')
plt.ylabel('Response Rate (%)')
plt.grid(axis='y', alpha=0.3)

# Add value labels
for bar, rate in zip(bars, response_rates.values):
    plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.5,
             f'{rate:.1f}%', ha='center', va='bottom')

plt.show()

print("üí° INSIGHT: Identifies which segments are most receptive to marketing")
print("   High response rate = better ROI on marketing spend")

# =============================================================================
# PLOT 4: INCOME VS SPENDING SCATTER PLOT
# =============================================================================

print("üìä PLOT 4: Income vs Spending Patterns by Segment")

plt.figure(figsize=(12, 8))

for segment in range(4):
    segment_data = df[df['Cluster'] == segment]
    plt.scatter(segment_data['Income'], segment_data['Total_Spent'],
               c=colors[segment], label=f'Segment {segment}', alpha=0.6, s=60)

plt.xlabel('Income ($)')
plt.ylabel('Total Spent ($)')
plt.title('Income vs Spending Patterns by Customer Segment', fontweight='bold', fontsize=14)
plt.legend()
plt.grid(True, alpha=0.3)

# Add trend line for reference
z = np.polyfit(df['Income'], df['Total_Spent'], 1)
p = np.poly1d(z)
plt.plot(df['Income'], p(df['Income']), "r--", alpha=0.8, label='Overall Trend')

plt.legend()
plt.show()

print("üí° INSIGHT: Shows the relationship between income and spending")
print("   Some segments spend more relative to income (good value)")
print("   Others spend less relative to income (growth potential)")

# =============================================================================
# PLOT 5: CAMPAIGN PERFORMANCE HEATMAP
# =============================================================================

print("üìä PLOT 5: Campaign Performance Heatmap by Segment")

plt.figure(figsize=(12, 8))

# Calculate response rates for each campaign by segment
campaign_columns = ['AcceptedCmp1', 'AcceptedCmp2', 'AcceptedCmp3', 'AcceptedCmp4', 'AcceptedCmp5', 'Response']
campaign_performance = df.groupby('Cluster')[campaign_columns].mean() * 100

# Create heatmap
sns.heatmap(campaign_performance,
            annot=True,
            fmt='.1f',
            cmap='YlGnBu',
            cbar_kws={'label': 'Response Rate (%)'},
            linewidths=1,
            linecolor='white')

plt.title('Campaign Response Rates by Segment (%)\n', fontweight='bold', fontsize=14)
plt.xlabel('Campaign')
plt.ylabel('Segment')
plt.tight_layout()
plt.show()

print("üí° INSIGHT: Shows which campaigns work best for each segment")
print("   Example: If Campaign 3 works well for Segment 2, use it again!")
print("   Helps optimize future campaign targeting")

